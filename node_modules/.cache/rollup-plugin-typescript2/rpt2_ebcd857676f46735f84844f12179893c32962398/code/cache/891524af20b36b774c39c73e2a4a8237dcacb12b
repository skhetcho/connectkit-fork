{"code":"import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { useEffect, useState } from 'react';\nimport { AnimatePresence } from 'framer-motion';\nimport { Container, ConnectingContainer, ConnectingAnimation, RetryButton, RetryIconContainer, Content, } from './styles';\nimport { PageContent, ModalHeading, ModalBody, ModalH1, ModalContentContainer, ModalContent, } from '../../Common/Modal/styles';\nimport Button from '../../Common/Button';\nimport Tooltip from '../../Common/Tooltip';\nimport Alert from '../../Common/Alert';\nimport SquircleSpinner from './SquircleSpinner';\nimport { RetryIconCircle } from '../../../assets/icons';\nimport BrowserIcon from '../../Common/BrowserIcon';\nimport { AlertIcon, TickIcon } from '../../../assets/icons';\nimport { detectBrowser, isWalletConnectConnector } from '../../../utils';\nimport useLocales from '../../../hooks/useLocales';\nimport { useConnect } from '../../../hooks/useConnect';\nimport { useContext } from '../../ConnectKit';\nimport { useWallet } from '../../../wallets/useWallets';\nimport CircleSpinner from './CircleSpinner';\nexport const states = {\n    CONNECTED: 'connected',\n    CONNECTING: 'connecting',\n    EXPIRING: 'expiring',\n    FAILED: 'failed',\n    REJECTED: 'rejected',\n    NOTCONNECTED: 'notconnected',\n    UNAVAILABLE: 'unavailable',\n};\nconst contentVariants = {\n    initial: {\n        willChange: 'transform,opacity',\n        position: 'relative',\n        opacity: 0,\n        scale: 0.95,\n    },\n    animate: {\n        position: 'relative',\n        opacity: 1,\n        scale: 1,\n        transition: {\n            ease: [0.16, 1, 0.3, 1],\n            duration: 0.4,\n            delay: 0.05,\n            position: { delay: 0 },\n        },\n    },\n    exit: {\n        position: 'absolute',\n        opacity: 0,\n        scale: 0.95,\n        transition: {\n            ease: [0.16, 1, 0.3, 1],\n            duration: 0.3,\n        },\n    },\n};\nconst ConnectWithInjector = ({ switchConnectMethod, forceState }) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const { connect } = useConnect({\n        mutation: {\n            onMutate: (connector) => {\n                if (connector.connector) {\n                    setStatus(states.CONNECTING);\n                }\n                else {\n                    setStatus(states.UNAVAILABLE);\n                }\n            },\n            onError(err) {\n                console.error(err);\n            },\n            onSettled(data, error) {\n                if (error) {\n                    setShowTryAgainTooltip(true);\n                    setTimeout(() => setShowTryAgainTooltip(false), 3500);\n                    if (error.code) {\n                        // https://github.com/MetaMask/eth-rpc-errors/blob/main/src/error-constants.ts\n                        switch (error.code) {\n                            case -32002:\n                                setStatus(states.NOTCONNECTED);\n                                break;\n                            case 4001:\n                                setStatus(states.REJECTED);\n                                break;\n                            default:\n                                setStatus(states.FAILED);\n                                break;\n                        }\n                    }\n                    else {\n                        // Sometimes the error doesn't respond with a code\n                        if (error.message) {\n                            switch (error.message) {\n                                case 'User rejected request':\n                                    setStatus(states.REJECTED);\n                                    break;\n                                default:\n                                    setStatus(states.FAILED);\n                                    break;\n                            }\n                        }\n                    }\n                }\n                else if (data) {\n                }\n                setTimeout(triggerResize, 100);\n            },\n        },\n    });\n    const { triggerResize, connector: c } = useContext();\n    const id = c.id;\n    const wallet = useWallet(id);\n    const walletInfo = {\n        name: wallet === null || wallet === void 0 ? void 0 : wallet.name,\n        shortName: (_a = wallet === null || wallet === void 0 ? void 0 : wallet.shortName) !== null && _a !== void 0 ? _a : wallet === null || wallet === void 0 ? void 0 : wallet.name,\n        icon: (_b = wallet === null || wallet === void 0 ? void 0 : wallet.iconConnector) !== null && _b !== void 0 ? _b : wallet === null || wallet === void 0 ? void 0 : wallet.icon,\n        iconShape: (_c = wallet === null || wallet === void 0 ? void 0 : wallet.iconShape) !== null && _c !== void 0 ? _c : 'circle',\n        iconShouldShrink: wallet === null || wallet === void 0 ? void 0 : wallet.iconShouldShrink,\n    };\n    const [showTryAgainTooltip, setShowTryAgainTooltip] = useState(false);\n    const expiryDefault = 9; // Starting at 10 causes layout shifting, better to start at 9\n    const [expiryTimer, setExpiryTimer] = useState(expiryDefault);\n    const browser = detectBrowser();\n    const extensionUrl = (_d = wallet === null || wallet === void 0 ? void 0 : wallet.downloadUrls) === null || _d === void 0 ? void 0 : _d[browser];\n    const suggestedExtension = (wallet === null || wallet === void 0 ? void 0 : wallet.downloadUrls)\n        ? {\n            name: Object.keys(wallet === null || wallet === void 0 ? void 0 : wallet.downloadUrls)[0],\n            label: ((_e = Object.keys(wallet === null || wallet === void 0 ? void 0 : wallet.downloadUrls)[0]) === null || _e === void 0 ? void 0 : _e.charAt(0).toUpperCase()) +\n                ((_f = Object.keys(wallet === null || wallet === void 0 ? void 0 : wallet.downloadUrls)[0]) === null || _f === void 0 ? void 0 : _f.slice(1)), // Capitalise first letter, but this might be better suited as a lookup table\n            url: wallet === null || wallet === void 0 ? void 0 : wallet.downloadUrls[Object.keys(wallet === null || wallet === void 0 ? void 0 : wallet.downloadUrls)[0]],\n        }\n        : undefined;\n    const [status, setStatus] = useState(forceState\n        ? forceState\n        : !(wallet === null || wallet === void 0 ? void 0 : wallet.isInstalled)\n            ? states.UNAVAILABLE\n            : states.CONNECTING);\n    const locales = useLocales({\n        CONNECTORNAME: walletInfo.name,\n        CONNECTORSHORTNAME: (_g = walletInfo.shortName) !== null && _g !== void 0 ? _g : walletInfo.name,\n        SUGGESTEDEXTENSIONBROWSER: (_h = suggestedExtension === null || suggestedExtension === void 0 ? void 0 : suggestedExtension.label) !== null && _h !== void 0 ? _h : 'your browser',\n    });\n    const runConnect = async () => {\n        if ((wallet === null || wallet === void 0 ? void 0 : wallet.isInstalled) && (wallet === null || wallet === void 0 ? void 0 : wallet.connector)) {\n            connect({ connector: wallet === null || wallet === void 0 ? void 0 : wallet.connector });\n        }\n        else {\n            setStatus(states.UNAVAILABLE);\n        }\n    };\n    let connectTimeout;\n    useEffect(() => {\n        if (status === states.UNAVAILABLE)\n            return;\n        // UX: Give user time to see the UI before opening the extension\n        connectTimeout = setTimeout(runConnect, 600);\n        return () => {\n            clearTimeout(connectTimeout);\n        };\n    }, []);\n    /** Timeout functionality if necessary\n    let expiryTimeout: any;\n    useEffect(() => {\n      if (status === states.EXPIRING) {\n        expiryTimeout = setTimeout(\n          () => {\n            if (expiryTimer <= 0) {\n              setStatus(states.FAILED);\n              setExpiryTimer(expiryDefault);\n            } else {\n              setExpiryTimer(expiryTimer - 1);\n            }\n          },\n          expiryTimer === 9 ? 1500 : 1000 // Google: Chronostasis\n        );\n      }\n      return () => {\n        clearTimeout(expiryTimeout);\n      };\n    }, [status, expiryTimer]);\n    */\n    if (!wallet) {\n        return (_jsx(PageContent, { children: _jsxs(Container, { children: [_jsx(ModalHeading, { children: \"Invalid State\" }), _jsx(ModalContent, { children: _jsx(Alert, { children: \"No connectors match the id given. This state should never happen.\" }) })] }) }));\n    }\n    // TODO: Make this more generic\n    if (isWalletConnectConnector(wallet === null || wallet === void 0 ? void 0 : wallet.connector.id)) {\n        return (_jsx(PageContent, { children: _jsxs(Container, { children: [_jsx(ModalHeading, { children: \"Invalid State\" }), _jsx(ModalContent, { children: _jsx(Alert, { children: \"WalletConnect does not have an injection flow. This state should never happen.\" }) })] }) }));\n    }\n    return (_jsx(PageContent, { children: _jsxs(Container, { children: [_jsx(ConnectingContainer, { children: _jsxs(ConnectingAnimation, { \"$shake\": status === states.FAILED || status === states.REJECTED, \"$circle\": walletInfo.iconShape === 'circle', children: [_jsx(AnimatePresence, { children: (status === states.FAILED || status === states.REJECTED) && (_jsx(RetryButton, { \"aria-label\": \"Retry\", initial: { opacity: 0, scale: 0.8 }, animate: { opacity: 1, scale: 1 }, exit: { opacity: 0, scale: 0.8 }, whileTap: { scale: 0.9 }, transition: { duration: 0.1 }, onClick: runConnect, children: _jsx(RetryIconContainer, { children: _jsx(Tooltip, { open: showTryAgainTooltip &&\n                                                (status === states.FAILED || status === states.REJECTED), message: locales.tryAgainQuestion, xOffset: -6, children: _jsx(RetryIconCircle, {}) }) }) })) }), walletInfo.iconShape === 'circle' ? (_jsx(CircleSpinner, { logo: status === states.UNAVAILABLE ? (_jsx(\"div\", { style: {\n                                        transform: 'scale(1.14)',\n                                        position: 'relative',\n                                        width: '100%',\n                                    }, children: walletInfo.icon })) : (_jsx(_Fragment, { children: walletInfo.icon })), smallLogo: walletInfo.iconShouldShrink, connecting: status === states.CONNECTING, unavailable: status === states.UNAVAILABLE })) : (_jsx(SquircleSpinner, { logo: status === states.UNAVAILABLE ? (_jsx(\"div\", { style: {\n                                        transform: 'scale(1.14)',\n                                        position: 'relative',\n                                        width: '100%',\n                                    }, children: walletInfo.icon })) : (_jsx(_Fragment, { children: walletInfo.icon })), connecting: status === states.CONNECTING }))] }) }), _jsx(ModalContentContainer, { children: _jsxs(AnimatePresence, { initial: false, children: [status === states.FAILED && (_jsx(Content, { initial: 'initial', animate: 'animate', exit: 'exit', variants: contentVariants, children: _jsxs(ModalContent, { children: [_jsxs(ModalH1, { \"$error\": true, children: [_jsx(AlertIcon, {}), locales.injectionScreen_failed_h1] }), _jsx(ModalBody, { children: locales.injectionScreen_failed_p })] }) }, states.FAILED)), status === states.REJECTED && (_jsx(Content, { initial: 'initial', animate: 'animate', exit: 'exit', variants: contentVariants, children: _jsxs(ModalContent, { style: { paddingBottom: 28 }, children: [_jsx(ModalH1, { children: locales.injectionScreen_rejected_h1 }), _jsx(ModalBody, { children: locales.injectionScreen_rejected_p })] }) }, states.REJECTED)), (status === states.CONNECTING || status === states.EXPIRING) && (_jsx(Content, { initial: 'initial', animate: 'animate', exit: 'exit', variants: contentVariants, children: _jsxs(ModalContent, { style: { paddingBottom: 28 }, children: [_jsx(ModalH1, { children: wallet.connector.id === 'injected'\n                                                ? locales.injectionScreen_connecting_injected_h1\n                                                : locales.injectionScreen_connecting_h1 }), _jsx(ModalBody, { children: wallet.connector.id === 'injected'\n                                                ? locales.injectionScreen_connecting_injected_p\n                                                : locales.injectionScreen_connecting_p })] }) }, states.CONNECTING)), status === states.CONNECTED && (_jsx(Content, { initial: 'initial', animate: 'animate', exit: 'exit', variants: contentVariants, children: _jsxs(ModalContent, { children: [_jsxs(ModalH1, { \"$valid\": true, children: [_jsx(TickIcon, {}), \" \", locales.injectionScreen_connected_h1] }), _jsx(ModalBody, { children: locales.injectionScreen_connected_p })] }) }, states.CONNECTED)), status === states.NOTCONNECTED && (_jsx(Content, { initial: 'initial', animate: 'animate', exit: 'exit', variants: contentVariants, children: _jsxs(ModalContent, { children: [_jsx(ModalH1, { children: locales.injectionScreen_notconnected_h1 }), _jsx(ModalBody, { children: locales.injectionScreen_notconnected_p })] }) }, states.NOTCONNECTED)), status === states.UNAVAILABLE && (_jsx(Content, { initial: 'initial', animate: 'animate', exit: 'exit', variants: contentVariants, children: !extensionUrl ? (_jsxs(_Fragment, { children: [_jsxs(ModalContent, { style: { paddingBottom: 12 }, children: [_jsx(ModalH1, { children: locales.injectionScreen_unavailable_h1 }), _jsx(ModalBody, { children: locales.injectionScreen_unavailable_p })] }), !wallet.isInstalled && suggestedExtension && (_jsxs(Button, { href: suggestedExtension === null || suggestedExtension === void 0 ? void 0 : suggestedExtension.url, icon: _jsx(BrowserIcon, { browser: suggestedExtension === null || suggestedExtension === void 0 ? void 0 : suggestedExtension.name }), children: [\"Install on \", suggestedExtension === null || suggestedExtension === void 0 ? void 0 : suggestedExtension.label] }))] })) : (_jsxs(_Fragment, { children: [_jsxs(ModalContent, { style: { paddingBottom: 18 }, children: [_jsx(ModalH1, { children: locales.injectionScreen_install_h1 }), _jsx(ModalBody, { children: locales.injectionScreen_install_p })] }), !wallet.isInstalled && extensionUrl && (_jsx(Button, { href: extensionUrl, icon: _jsx(BrowserIcon, {}), children: locales.installTheExtension }))] })) }, states.UNAVAILABLE))] }) })] }) }));\n};\nexport default ConnectWithInjector;\n","references":["C:/Users/Volcano/Desktop/avo/3rd-party-libraries/connectkit/node_modules/@types/react/index.d.ts","C:/Users/Volcano/Desktop/avo/3rd-party-libraries/connectkit/node_modules/framer-motion/dist/index.d.ts","C:/Users/Volcano/Desktop/avo/3rd-party-libraries/connectkit/packages/connectkit/src/components/ConnectModal/ConnectWithInjector/styles.ts","C:/Users/Volcano/Desktop/avo/3rd-party-libraries/connectkit/packages/connectkit/src/components/Common/Modal/styles.ts","C:/Users/Volcano/Desktop/avo/3rd-party-libraries/connectkit/packages/connectkit/src/components/Common/Modal/index.tsx","C:/Users/Volcano/Desktop/avo/3rd-party-libraries/connectkit/packages/connectkit/src/components/Common/Button/index.tsx","C:/Users/Volcano/Desktop/avo/3rd-party-libraries/connectkit/packages/connectkit/src/components/Common/Tooltip/index.tsx","C:/Users/Volcano/Desktop/avo/3rd-party-libraries/connectkit/packages/connectkit/src/components/Common/Alert/index.tsx","C:/Users/Volcano/Desktop/avo/3rd-party-libraries/connectkit/packages/connectkit/src/components/ConnectModal/ConnectWithInjector/SquircleSpinner/index.tsx","C:/Users/Volcano/Desktop/avo/3rd-party-libraries/connectkit/packages/connectkit/src/assets/icons.tsx","C:/Users/Volcano/Desktop/avo/3rd-party-libraries/connectkit/packages/connectkit/src/components/Common/BrowserIcon/index.tsx","C:/Users/Volcano/Desktop/avo/3rd-party-libraries/connectkit/packages/connectkit/src/assets/icons.tsx","C:/Users/Volcano/Desktop/avo/3rd-party-libraries/connectkit/packages/connectkit/src/utils/index.ts","C:/Users/Volcano/Desktop/avo/3rd-party-libraries/connectkit/packages/connectkit/src/hooks/useLocales.tsx","C:/Users/Volcano/Desktop/avo/3rd-party-libraries/connectkit/packages/connectkit/src/hooks/useConnect.tsx","C:/Users/Volcano/Desktop/avo/3rd-party-libraries/connectkit/packages/connectkit/src/components/ConnectKit.tsx","C:/Users/Volcano/Desktop/avo/3rd-party-libraries/connectkit/packages/connectkit/src/wallets/useWallets.tsx","C:/Users/Volcano/Desktop/avo/3rd-party-libraries/connectkit/packages/connectkit/src/components/ConnectModal/ConnectWithInjector/CircleSpinner/index.tsx"],"dts":{"name":"C:/Users/Volcano/Desktop/avo/3rd-party-libraries/connectkit/packages/connectkit/build/components/ConnectModal/ConnectWithInjector/index.d.ts","writeByteOrderMark":false,"text":"import React from 'react';\nexport declare const states: {\n    CONNECTED: string;\n    CONNECTING: string;\n    EXPIRING: string;\n    FAILED: string;\n    REJECTED: string;\n    NOTCONNECTED: string;\n    UNAVAILABLE: string;\n};\ndeclare const ConnectWithInjector: React.FC<{\n    switchConnectMethod: (id?: string) => void;\n    forceState?: typeof states;\n}>;\nexport default ConnectWithInjector;\n"}}
